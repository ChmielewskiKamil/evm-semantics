<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="K Semantics of the Ethereum Virtual Machine (EVM)"
/>
<meta
  name="keywords"
  content="runtime, verification, rv, k, ethereum virtual machine, evm"
/>
<meta name="author" content="EVM Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../assets/img/favicon.ico" />

<title>KEVM: Semantics of EVM in K | Runtime Verification, Inc. </title>

<link rel="canonical" href="https://jellopaper.org/evm-node/" />

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../index.html"> EVM Semantics </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/evm-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <!--
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../downloads"
    >Download</a
  >
  -->
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../">Homepage</a>
      <a class="bd-toc-link" href="../INSTALL/">Install</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-6 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1 id="evm-integration-with-production-client">EVM Integration with Production Client</h1>
<p>Contained in this file is glue code needed in order to enable the ability to use KEVM as a VM for an actual Ethereum node.</p>
<pre class="language-text"><code>requires &quot;evm.md&quot;
requires &quot;optimizations.md&quot;

module EVM-NODE
    imports EVM
    imports EVM-OPTIMIZATIONS
    imports K-REFLECTION
    imports COLLECTIONS
    imports BYTES

  configuration
    &lt;kevm/&gt;
    &lt;loaded&gt; false &lt;/loaded&gt;
</code></pre>
<h3 id="state-loading-operations.">State loading operations.</h3>
<p>In order to enable scalable execution of transactions on an entire blockchain, it is necessary to avoid serializing/deserializing the entire state of all accounts when constructing the initial configuration for KEVM.
To do this, we assume that accounts not present in the <code>&lt;accounts&gt;</code> cell might not exist and need to be loaded on each access.
We also defer loading of storage entries and the actual code byte string until it is needed.
Because the same account may be loaded more than once, implementations of this interface are expected to cache the actual query to the Ethereum client.</p>
<ul>
<li><code>#unloaded</code> represents the code of an account that has not had its code loaded yet. Unloaded code may not be empty.</li>
<li>Empty code is detected without lazy evaluation by means of checking the code hash, and therefore will always be represented in the <code>&lt;code&gt;</code> cell as <code>.WordStack</code>.</li>
</ul>
<pre class="language-text"><code>    syntax InternalOp ::= &quot;#load&quot; &quot;[&quot; OpCode &quot;]&quot;
 // --------------------------------------------
    rule &lt;k&gt; (. =&gt; #load [ OP ]) ~&gt; #next [ OP ] ... &lt;/k&gt;
         &lt;loaded&gt; false =&gt; true &lt;/loaded&gt;
      [priority(35)]

    rule &lt;k&gt; #execute ... &lt;/k&gt;
         &lt;loaded&gt; true =&gt; false &lt;/loaded&gt;
      [priority(35)]
</code></pre>
<ul>
<li><code>CREATE2</code> is a special case
Note that we cannot execute #loadAccount during the #load phase earlier because gas will not yet
have been paid, and it may be to expensive to compute the hash of the init code.</li>
</ul>
<pre class="language-text"><code>    rule &lt;k&gt; #gas [ CREATE2, _ ] ... &lt;/k&gt;
         &lt;loaded&gt; true =&gt; false &lt;/loaded&gt;
      [priority(35)]

    rule &lt;k&gt; (. =&gt; #loadAccount #newAddr(ACCT, SALT, #range(LM, MEMSTART, MEMWIDTH)))
          ~&gt; CREATE2 _VALUE MEMSTART MEMWIDTH SALT
         ...
         &lt;/k&gt;
         &lt;id&gt; ACCT &lt;/id&gt;
         &lt;localMem&gt; LM &lt;/localMem&gt;
         &lt;loaded&gt; false =&gt; true &lt;/loaded&gt;
      [priority(35)]
</code></pre>
<pre class="language-text"><code>    rule &lt;k&gt; #load [ OP:OpCode ] =&gt; #loadAccount W0 ~&gt; #lookupCode W0 ... &lt;/k&gt;
         &lt;wordStack&gt; W0 : _ &lt;/wordStack&gt;
      requires isAddr1Op(OP)

    rule &lt;k&gt; #load [ OP:OpCode ] =&gt; #loadAccount W1 ~&gt; #lookupCode W1 ... &lt;/k&gt;
         &lt;wordStack&gt; _ : W1 : _ &lt;/wordStack&gt;
      requires isAddr2Op(OP)

    rule &lt;k&gt; #load [ CREATE ] =&gt; #loadAccount #newAddr(ACCT, NONCE) ... &lt;/k&gt;
         &lt;id&gt; ACCT &lt;/id&gt;
         &lt;account&gt;
           &lt;acctID&gt; ACCT &lt;/acctID&gt;
           &lt;nonce&gt; NONCE &lt;/nonce&gt;
           ...
         &lt;/account&gt;

    rule &lt;k&gt; #load [ OP:OpCode ] =&gt; #lookupStorage ACCT W0 ... &lt;/k&gt;
         &lt;id&gt; ACCT &lt;/id&gt;
         &lt;wordStack&gt; W0 : _ &lt;/wordStack&gt;
      requires OP ==K SSTORE orBool OP ==K SLOAD

    rule &lt;k&gt; #load [ _OP:OpCode ] =&gt; . ... &lt;/k&gt; [owise]
</code></pre>
<pre class="language-text"><code>    syntax AccountCode ::= #unloaded(Int)
</code></pre>
<ul>
<li><code>#getBalance</code> returns the balance of an account that exists based on its integer address.</li>
<li><code>#getNonce</code> returns the nonce of an account that exists based on its integer address.</li>
<li><code>#isCodeEmpty</code> returns true if the code hash of the account is equal to the hash of the empty string, and false otherwise.</li>
<li><code>#accountExists</code> returns true if the account is present in the state trie for the current block, and false otherwise.</li>
</ul>
<pre class="language-text"><code>    syntax Int  ::= #getBalance  ( Int ) [function, hook(BLOCKCHAIN.getBalance)]
                  | #getNonce    ( Int ) [function, hook(BLOCKCHAIN.getNonce)]
                  | #getCodeHash ( Int ) [function]
 // -----------------------------------------------------------------------------
    rule #getCodeHash(ACCT) =&gt; keccak(#parseByteStackRaw(#getCode(ACCT)))

    syntax Bool ::= #isCodeEmpty   ( Int ) [function, hook(BLOCKCHAIN.isCodeEmpty)]
                  | #accountExists ( Int ) [function, hook(BLOCKCHAIN.accountExists)]
 // ---------------------------------------------------------------------------------
</code></pre>
<p>The following operations help with loading account information from an external running client.
This minimizes the amount of information which must be stored in the configuration.</p>
<ul>
<li><code>#loadAccount</code> queries for account data from the running client.</li>
<li><code>#lookupCode</code> loads the code of an account into the <code>&lt;code&gt;</code> cell.</li>
<li><code>#lookupStorage</code> loads the value of the specified storage key into the <code>&lt;storage&gt;</code> cell.</li>
</ul>
<pre class="language-k"><code>    <span class="token keyword">syntax</span> InternalOp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;#loadAccount&quot;</span>   <span class="token keyword">Int</span>
                        <span class="token operator">|</span> <span class="token string">&quot;#lookupCode&quot;</span>    <span class="token keyword">Int</span>
                        <span class="token operator">|</span> <span class="token string">&quot;#lookupStorage&quot;</span> <span class="token keyword">Int</span> <span class="token keyword">Int</span>
 <span class="token comment">// ----------------------------------------------</span>
</code></pre>
<ul>
<li><code>#loadAccount</code> loads an account&apos;s balance and nonce if it exists, and leaves the code and storage unloaded, except if the code is empty, in which case the code is fully loaded.
If the account does not exist, it does nothing.</li>
</ul>
<pre class="language-text"><code>    rule &lt;k&gt; #loadAccount ACCT =&gt; . ... &lt;/k&gt;
         &lt;activeAccounts&gt; ACCTS (.Set =&gt; SetItem(ACCT)) &lt;/activeAccounts&gt;
         &lt;accounts&gt;
           ( .Bag
          =&gt; &lt;account&gt;
               &lt;acctID&gt; ACCT &lt;/acctID&gt;
               &lt;balance&gt; #getBalance(ACCT) &lt;/balance&gt;
               &lt;code&gt; #if #isCodeEmpty(ACCT) #then .ByteArray #else #unloaded(#getCodeHash(ACCT)) #fi &lt;/code&gt;
               &lt;storage&gt; .Map &lt;/storage&gt;
               &lt;origStorage&gt; .Map &lt;/origStorage&gt;
               &lt;nonce&gt; #getNonce(ACCT) &lt;/nonce&gt;
             &lt;/account&gt;
           )
           ...
         &lt;/accounts&gt;
      requires notBool ACCT in ACCTS andBool #accountExists(ACCT)

    rule &lt;k&gt; #loadAccount ACCT =&gt; . ... &lt;/k&gt;
         &lt;activeAccounts&gt; ACCTS &lt;/activeAccounts&gt;
      requires ACCT in ACCTS orBool notBool #accountExists(ACCT)
</code></pre>
<ul>
<li><code>#getStorageData</code> loads the value for a single storage key of a specified account by its address and storage offset.
If the storage key has already been loaded or the account does not exist, it does nothing.</li>
</ul>
<pre class="language-text"><code>    syntax Int ::= #getStorageData ( Int , Int ) [function, hook(BLOCKCHAIN.getStorageData)]
 // ----------------------------------------------------------------------------------------
    rule &lt;k&gt; #lookupStorage ACCT INDEX =&gt; . ... &lt;/k&gt;
         &lt;account&gt;
           &lt;acctID&gt;  ACCT                                                         &lt;/acctID&gt;
           &lt;storage&gt; STORAGE =&gt; STORAGE [ INDEX &lt;- #getStorageData(ACCT, INDEX) ] &lt;/storage&gt;
           &lt;origStorage&gt; ORIGSTORAGE =&gt; ORIGSTORAGE [ INDEX &lt;- #getStorageData(ACCT, INDEX) ] &lt;/origStorage&gt;
           ...
         &lt;/account&gt;
      requires notBool INDEX in_keys(STORAGE)

    rule &lt;k&gt; #lookupStorage ACCT INDEX =&gt; . ... &lt;/k&gt;
         &lt;account&gt;
           &lt;acctID&gt; ACCT &lt;/acctID&gt;
           &lt;storage&gt; STORAGE:Map &lt;/storage&gt;
           ...
         &lt;/account&gt;
      requires INDEX in_keys(STORAGE)

    rule &lt;k&gt; #lookupStorage ACCT _ =&gt; . ... &lt;/k&gt;
      requires notBool #accountExists(ACCT)
</code></pre>
<ul>
<li><code>#getCode</code> loads the code for a specified account by its address. If the code has already been loaded, it does nothing.
If the account does not exist, it also does nothing.</li>
</ul>
<pre class="language-text"><code>    syntax String ::= #getCode ( Int ) [function, hook(BLOCKCHAIN.getCode)]
 // -----------------------------------------------------------------------
    rule &lt;k&gt; #lookupCode ACCT =&gt; . ... &lt;/k&gt;
         &lt;account&gt;
           &lt;acctID&gt; ACCT &lt;/acctID&gt;
           &lt;code&gt; #unloaded(_) =&gt; #parseByteStackRaw(#getCode(ACCT)) &lt;/code&gt;
           ...
         &lt;/account&gt;

    rule &lt;k&gt; #lookupCode ACCT =&gt; . ... &lt;/k&gt;
         &lt;account&gt;
           &lt;acctID&gt; ACCT &lt;/acctID&gt;
           &lt;code&gt; _:ByteArray &lt;/code&gt;
           ...
         &lt;/account&gt;

    rule &lt;k&gt; #lookupCode ACCT =&gt; . ... &lt;/k&gt;
      requires notBool #accountExists(ACCT)
</code></pre>
<ul>
<li><code>#getBlockhash(N)</code> returns the blockhash of the Nth most recent block, up to a maximum of 256 blocks.
It is used in the implementation of the BLOCKHASH instruction as seen below.</li>
</ul>
<pre class="language-text"><code>    syntax Int ::= #getBlockhash ( Int ) [function, hook(BLOCKCHAIN.getBlockhash)]
 // ------------------------------------------------------------------------------
    rule &lt;k&gt; BLOCKHASH N =&gt; #getBlockhash(N) ~&gt; #push ... &lt;/k&gt; &lt;mode&gt; NORMAL &lt;/mode&gt; requires N &gt;=Int 0 andBool N  &lt;Int 256
    rule &lt;k&gt; BLOCKHASH N =&gt; 0                ~&gt; #push ... &lt;/k&gt; &lt;mode&gt; NORMAL &lt;/mode&gt; requires N  &lt;Int 0  orBool N &gt;=Int 256
</code></pre>
<pre class="language-text"><code>    rule keccak({#unloaded(HASH)}:&gt;ByteArray) =&gt; HASH
</code></pre>
<h3 id="transaction-execution">Transaction Execution</h3>
<ul>
<li><code>runVM</code> takes all the input state of a transaction and the current block header and executes the transaction according to the specified state, relying on the above loading operations for access to accounts and block hashes.
The signature of this function must match the signature expected by VM.ml in the blockchain-k-plugin.</li>
</ul>
<pre class="language-text"><code>    syntax EthereumSimulation ::= runVM ( iscreate: Bool , to: Int          , from: Int       , code: String  , args: String  , value: Int     , gasprice: Int
                                        , gas: Int       , beneficiary: Int , difficulty: Int , number: Int   , gaslimit: Int , timestamp: Int , unused: String ) [symbol]
 // ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
    rule &lt;k&gt; (.K =&gt; #loadAccount ACCTFROM) ~&gt; runVM(... from: ACCTFROM) ... &lt;/k&gt;
         &lt;activeAccounts&gt; .Set &lt;/activeAccounts&gt;

    rule &lt;k&gt; runVM(true, _, ACCTFROM, _, ARGS, VALUE, GPRICE, GAVAIL, CB, DIFF, NUMB, GLIMIT, TS, _)
          =&gt; #loadAccount #newAddr(ACCTFROM, NONCE -Int 1)
          ~&gt; #create ACCTFROM #newAddr(ACCTFROM, NONCE -Int 1) VALUE #parseByteStackRaw(ARGS)
          ~&gt; #codeDeposit #newAddr(ACCTFROM, NONCE -Int 1)
          ~&gt; #endCreate
         ...
         &lt;/k&gt;
         &lt;gasPrice&gt; _ =&gt; GPRICE &lt;/gasPrice&gt;
         &lt;callGas&gt; _ =&gt; GAVAIL &lt;/callGas&gt;
         &lt;origin&gt; _ =&gt; ACCTFROM &lt;/origin&gt;
         &lt;callDepth&gt; _ =&gt; -1 &lt;/callDepth&gt;
         &lt;coinbase&gt; _ =&gt; CB &lt;/coinbase&gt;
         &lt;difficulty&gt; _ =&gt; DIFF &lt;/difficulty&gt;
         &lt;number&gt; _ =&gt; NUMB &lt;/number&gt;
         &lt;gasLimit&gt; _ =&gt; GLIMIT &lt;/gasLimit&gt;
         &lt;timestamp&gt; _ =&gt; TS &lt;/timestamp&gt;
         &lt;account&gt;
           &lt;acctID&gt; ACCTFROM &lt;/acctID&gt;
           &lt;nonce&gt; NONCE &lt;/nonce&gt;
           ...
         &lt;/account&gt;
         &lt;touchedAccounts&gt; _ =&gt; SetItem(CB) &lt;/touchedAccounts&gt;
         &lt;activeAccounts&gt; ACCTS &lt;/activeAccounts&gt;
         &lt;accessedAccounts&gt; ACCESSED =&gt; ACCESSED |Set SetItem(ACCTFROM) |Set SetItem(#newAddr(ACCTFROM, NONCE -Int 1)) &lt;/accessedAccounts&gt;
      requires ACCTFROM in ACCTS

    rule &lt;k&gt; runVM(false, ACCTTO, ACCTFROM, _, ARGS, VALUE, GPRICE, GAVAIL, CB, DIFF, NUMB, GLIMIT, TS, _)
          =&gt; #loadAccount ACCTTO
          ~&gt; #lookupCode ACCTTO
          ~&gt; #call ACCTFROM ACCTTO ACCTTO VALUE VALUE #parseByteStackRaw(ARGS) false
          ~&gt; #endVM
         ...
         &lt;/k&gt;
         &lt;gasPrice&gt; _ =&gt; GPRICE &lt;/gasPrice&gt;
         &lt;callGas&gt; _ =&gt; GAVAIL &lt;/callGas&gt;
         &lt;origin&gt; _ =&gt; ACCTFROM &lt;/origin&gt;
         &lt;callDepth&gt; _ =&gt; -1 &lt;/callDepth&gt;
         &lt;coinbase&gt; _ =&gt; CB &lt;/coinbase&gt;
         &lt;difficulty&gt; _ =&gt; DIFF &lt;/difficulty&gt;
         &lt;number&gt; _ =&gt; NUMB &lt;/number&gt;
         &lt;gasLimit&gt; _ =&gt; GLIMIT &lt;/gasLimit&gt;
         &lt;timestamp&gt; _ =&gt; TS &lt;/timestamp&gt;
         &lt;touchedAccounts&gt; _ =&gt; SetItem(CB) &lt;/touchedAccounts&gt;
         &lt;activeAccounts&gt; ACCTS &lt;/activeAccounts&gt;
         &lt;accessedAccounts&gt; ACCESSED =&gt; ACCESSED |Set SetItem(ACCTFROM) |Set SetItem(ACCTTO) &lt;/accessedAccounts&gt;
      requires ACCTFROM in ACCTS
</code></pre>
<ul>
<li><code>makeAccessList</code> will initialize the <code>&lt;accessedAccounts&gt;</code> and <code>&lt;accessedStorage&gt;</code> cells for an access list transaction type and leave runVM at the top of the <code>&lt;k&gt;</code> cell.</li>
</ul>
<pre class="language-text"><code>    syntax KItem ::= storageLocation ( Int, Int ) [symbol]
    syntax EthereumSimulation ::= makeAccessList ( accessedAddresses: Set, storageList: Set , runvm: EthereumSimulation ) [symbol]
 // ------------------------------------------------------------------------------------------------------------------------------
    rule &lt;k&gt; makeAccessList( ACCESSED, .Set, RUNVM ) =&gt; RUNVM ... &lt;/k&gt;
         &lt;accessedAccounts&gt; _ =&gt; ACCESSED &lt;/accessedAccounts&gt;

    rule &lt;k&gt; makeAccessList( _, SetItem(storageLocation(ACCT, LOCATION)) STORAGELIST =&gt; STORAGELIST, _ ) ... &lt;/k&gt;
         &lt;accessedStorage&gt; ... ACCT |-&gt; (LOCATIONS =&gt; LOCATIONS |Set SetItem(LOCATION)) ... &lt;/accessedStorage&gt;

    rule &lt;k&gt; makeAccessList( _, SetItem(storageLocation(ACCT, LOCATION)) STORAGELIST =&gt; STORAGELIST, _ ) ... &lt;/k&gt;
         &lt;accessedStorage&gt; STORAGEMAP =&gt; STORAGEMAP[ACCT &lt;- SetItem(LOCATION)] &lt;/accessedStorage&gt;
      requires notBool ACCT in_keys(STORAGEMAP)
</code></pre>
<ul>
<li><code>#endCreate</code> and <code>#endVM</code> clean up after the transaction finishes and store the return status code of the top level call frame on the top of the <code>&lt;k&gt;</code> cell.</li>
</ul>
<pre class="language-text"><code>    syntax KItem ::= &quot;#endVM&quot; | &quot;#endCreate&quot;
 // ----------------------------------------
    rule &lt;statusCode&gt; _:ExceptionalStatusCode &lt;/statusCode&gt;
         &lt;k&gt; #halt ~&gt; #endVM =&gt; #popCallStack ~&gt; #popWorldState ~&gt; 0 &lt;/k&gt;
         &lt;output&gt; _ =&gt; .ByteArray &lt;/output&gt;

    rule &lt;statusCode&gt; EVMC_REVERT &lt;/statusCode&gt;
         &lt;k&gt; #halt ~&gt; #endVM =&gt; #popCallStack ~&gt; #popWorldState ~&gt; #refund GAVAIL ~&gt; 0 &lt;/k&gt;
         &lt;gas&gt; GAVAIL &lt;/gas&gt;

    rule &lt;statusCode&gt; EVMC_SUCCESS &lt;/statusCode&gt;
         &lt;k&gt; #halt ~&gt; #endVM =&gt; #popCallStack ~&gt; #dropWorldState ~&gt; #refund GAVAIL ~&gt; 1 &lt;/k&gt;
         &lt;gas&gt; GAVAIL &lt;/gas&gt;

    rule &lt;k&gt; #endCreate =&gt; W ... &lt;/k&gt; &lt;wordStack&gt; W : _WS &lt;/wordStack&gt;
</code></pre>
<h3 id="primitive-operations-expected-to-exist-by-the-blockchain-k-plugin">Primitive operations expected to exist by the blockchain-k-plugin</h3>
<ul>
<li><code>vmResult</code> represents the extracted information about the world state after the transaction finishes.
Its signature must match the signature expected by VM.ml in the blockchain-k-plugin.</li>
<li><code>extractConfig</code> takes a final configuration after rewriting and extracts a <code>vmResult</code> from it in order to abstract away configuration structure from the postprocessing done by the blockchain-k-plugin.</li>
</ul>
<pre class="language-text"><code>    syntax KItem ::= vmResult ( return: String , gas: Int , refund: Int , status: Int , selfdestruct: Set , logs: List , AccountsCell , touched: Set , statusCode: String )
    syntax KItem ::= extractConfig() [function, symbol]
 // ---------------------------------------------------
    rule [[ extractConfig() =&gt; vmResult(#unparseByteStack(OUT), GAVAIL, REFUND, STATUS, SD, LOGS, &lt;accounts&gt; ACCTS &lt;/accounts&gt;, TOUCHED, StatusCode2String(STATUSCODE)) ]]
         &lt;output&gt; OUT &lt;/output&gt;
         &lt;gas&gt; GAVAIL &lt;/gas&gt;
         &lt;refund&gt; REFUND &lt;/refund&gt;
         &lt;k&gt; STATUS:Int &lt;/k&gt;
         &lt;selfDestruct&gt; SD &lt;/selfDestruct&gt;
         &lt;log&gt; LOGS &lt;/log&gt;
         &lt;accounts&gt; ACCTS &lt;/accounts&gt;
         &lt;touchedAccounts&gt; TOUCHED &lt;/touchedAccounts&gt;
         &lt;statusCode&gt; STATUSCODE &lt;/statusCode&gt;

    syntax KItem ::= accessListResult( accountsSet: Set, storageSet: Set ) [symbol]
    syntax KItem ::= extractAccessList() [function, symbol]
 // -------------------------------------------------------------------------------
    rule [[ extractAccessList() =&gt; accessListResult( ACCESSED, warmStorage2Set( keys_list(STORAGE), STORAGE, .Set) ) ]]
         &lt;accessedAccounts&gt; ACCESSED &lt;/accessedAccounts&gt;
         &lt;accessedStorage&gt;  STORAGE  &lt;/accessedStorage&gt;

    syntax Set ::= warmStorage2Set   ( List, Map, Set ) [function]
                 | warmStorage2SetAux( Int, List, Set ) [function]
 // --------------------------------------------------------------
    rule warmStorage2Set( .List, _, STORAGELIST ) =&gt; STORAGELIST
    rule warmStorage2Set( (ListItem(ACCT) =&gt; .List) _, STORAGE, RESULT =&gt; RESULT |Set warmStorage2SetAux(ACCT, Set2List({STORAGE[ACCT]}:&gt;Set), .Set) )

    rule warmStorage2SetAux( _, .List, RESULT ) =&gt; RESULT
    rule warmStorage2SetAux( ACCT, (ListItem(LOCATION) =&gt; .List) _LOCATIONS, RESULT =&gt; RESULT |Set SetItem(storageLocation(ACCT, LOCATION)) )
</code></pre>
<ul>
<li><code>contractBytes</code> takes the contents of the <code>&lt;code&gt;</code> cell and returns its binary representation as a String.</li>
</ul>
<pre class="language-text"><code>    syntax String ::= contractBytes(AccountCode) [function, symbol]
 // ---------------------------------------------------------------
    rule contractBytes(WS) =&gt; #unparseByteStack(WS)
</code></pre>
<p>The following are expected to exist in the client, but are already defined in [data.md].</p>
<ul>
<li><code>accountEmpty</code> takes the contents of the <code>&lt;code&gt;</code> cell, the contents of the <code>&lt;nonce&gt;</code> cell, and the contents of the <code>&lt;balance&gt;</code> cell and returns true if the account is empty according to the semantics of EIP161 (i.e., empty code zero balance zero nonce).</li>
<li><code>unparseByteStack</code> takes a WordStack and returns the corresponding byte String.</li>
<li><code>initKevmCell</code> is the top cell initializer used to construct an initial configuration.
The configuration is expected to have <code>$MODE</code>, <code>$PGM</code>, and <code>$SCHEDULE</code> parameters.</li>
<li><code>logEntry</code> is an entry in the log data created by a transaction.
It is expected to consist of an Int address, a List of Int topics, and a WordStack of data.</li>
<li><code>NORMAL</code> is the value of <code>$MODE</code> used by actual transaction execution.</li>
</ul>
<pre class="language-text"><code>endmodule
</code></pre>
</body></html></div>
        </main>

        <!-- Page ToC -->
        <div class="col-12 col-md-3 col-xl-2 py-md-3 bd-sidebar page-toc mb-3">
          
<div>
<div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#evm-integration-with-production-client"
                class="bd-toc-link"
                style="padding-left: 0px;;"
              >
                EVM Integration with Production Client
              </a></div>
</div>

        </div>
        <div class="btn btn-rv-blue page-toc-toggle-btn"></div>
        <!-- End Page ToC -->
      </div>
    </div>
<!-- The footer is now controlled by the k-web-theme git submodule -->
<footer id="rvsite-footer" class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-4 mb-md-0 mb-4">
        <a href="https://runtimeverification.com/" target="_blank">
          <picture>
            <source
              srcset="
                https://runtimeverification.com/assets/img/rv-logo-dark.png
              "
              media="(prefers-color-scheme: dark)"
            />
            <img
              class="logo-dark"
              src="https://runtimeverification.com/assets/img/rv-logo.png"
              alt="Runtime Verification logo"
              style="height: 32px"
            /> </picture
        ></a>
        <p class="mt-2 text-md-left copyright">
          <a href="https://goo.gl/maps/NYzr2iKpXMgEmQ2F6" target="_blank"
            >102 E Main St #500, Urbana, IL 61801</a
          >
        </p>
      </div>
      <div class="col-md-4 text-md-center mb-md-0 mb-4"></div>
      <div class="col-md-4 mb-md-0 mb-4 text-md-right">
        <p class="copyright">2022 © all rights reserved</p>
      </div>
    </div>
  </div>
</footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../assets/js/index.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=G-QL0D8HRYFW"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "G-QL0D8HRYFW");
</script>

  </body>
</html>
